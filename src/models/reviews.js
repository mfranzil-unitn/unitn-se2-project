const db = require('@app/models');
const Logger = require('@app/loaders/logger');

const queries = {
    insert: "INSERT INTO review (review_user_id, review_line_id, review_rating, review_description)"
        + " VALUES ($1, $2, $3, $4) RETURNING review_id",
    update: "UPDATE review SET (review_user_id, review_line_id, review_rating, review_description)"
        + " = ($2, $3, $4, $5) WHERE review_id = $1;",
    delete: "DELETE FROM review WHERE review_id = $1;",
    getByPrimaryKey: "SELECT * FROM review WHERE review_id = $1",
    getAll: "SELECT * FROM review;",
    getAllLimited: "SELECT * FROM review LIMIT $1 OFFSET $2;",
    getCount: "SELECT COUNT(*) FROM review;"
};

// review = {review_id : Number,  review_user_id : String,
//           review_line_id : Number, review_rating : Number, review_description: String}
// review_id is autogenerated by Postgres
// review_user_id is a foreign key to User
// review_line_id is a foreign key to Line
// review_rating is Numeric(2,1) (es. 1.2)

module.exports = {
    insert: async ({ review_user_id, review_line_id, review_rating, review_description }) => {
        try {
            let res = await db.executeQuery(queries.insert, review_user_id, parseInt(review_line_id),
                parseFloat(review_rating), review_description);
            return res.rows[0].review_id;
        } catch (error) {
          throw new Error('Error in Insert');
          console.log(error.stack);
          return -1;
        }
    },
    update: async ({ review_id, review_user_id, review_line_id, review_rating, review_description }) => {
        try {
            let res = await db.executeQuery(queries.update, parseInt(review_id), review_user_id, parseInt(review_line_id),
                parseFloat(review_rating), review_description);
            return res.rowCount;
        } catch (error) {
            Logger.error(error.stack);
            return -1;
        }
    },
    delete: async (primaryKey) => {
        try {
            let res = await db.executeQuery(queries.delete, parseInt(primaryKey));
            console.log(res.rows.length);
            return res.rowCount;
        } catch (error) {
            Logger.error(error.stack);
            return -1;
        }
    },
    getByPrimaryKey: async (primaryKey) => {
        try {
            let res = await db.executeQuery(queries.getByPrimaryKey, parseInt(primaryKey));
            return res.rows.length === 1 ? res.rows[0] : undefined;
        } catch (error) {
            Logger.error(error.stack);
            return undefined;
        }
    },
    getAll: async (limit, offset) => {
        try {
            let res = undefined;
            if (!!limit && !!offset) {
                res = await db.executeQuery(queries.getAllLimited, limit, offset);
            } else {
                res = await db.executeQuery(queries.getAll);
            }
            return res.rows;
            } catch (error) {
                Logger.error(error.stack);
                return undefined;
            }
        },
    getCount: async () => {
        try {
            let res = await db.executeQuery(queries.getCount);
            return res.rows;
        } catch (error) {
            Logger.error(error.stack);
            return undefined;
        }
    }
}
